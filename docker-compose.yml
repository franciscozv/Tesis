version: '3.8'

# This Docker Compose file is configured for a production environment.
# It defines two services: 'backend' and 'frontend', connected via a custom network.

services:
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: tesis-backend
    restart: unless-stopped
    # The backend is not exposed to the outside world directly for security.
    # It's only accessible from other containers on the same network (i.e., the frontend).
    expose:
      - "${PORT}" # Internal port, read from .env file (defaults to 8080)
    environment:
      # All environment variables are loaded from an .env file in the same directory
      # as this docker-compose.yml file. This keeps secrets out of version control.
      - NODE_ENV=production
      - DATABASE_URL=${DATABASE_URL}
      - PORT=${PORT}
      - CORS_ORIGIN=${CORS_ORIGIN}
      - COMMON_RATE_LIMIT_WINDOW_MS=${COMMON_RATE_LIMIT_WINDOW_MS}
      - COMMON_RATE_LIMIT_MAX_REQUESTS=${COMMON_RATE_LIMIT_MAX_REQUESTS}
    networks:
      - tesis-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:${PORT}/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: tesis-frontend
    restart: unless-stopped
    ports:
      # Maps port 1709 on the host server to port 3000 inside the container.
      # This makes the frontend accessible via http://<server_ip>:1709
      - "1709:3000"
    environment:
      # This URL is used by the Next.js app to make API calls to the backend.
      # 'backend' is the service name defined above. Docker's internal DNS resolves it.
      - NEXT_PUBLIC_API_URL=http://backend:${PORT}
      - NODE_ENV=production
      - PORT=3000
    depends_on:
      backend:
        condition: service_healthy
    networks:
      - tesis-network

# Defines the custom network that allows containers to communicate with each other.
networks:
  tesis-network:
    driver: bridge